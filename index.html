<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Étude Application Python/PostgreSQL | Plateforme d'Optimisation des EDT Universitaires</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #1d2a5f;
            --primary-dark: #041956;
            --secondary: #094253;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --success: #4bb543;
            --error: #f94144;
            --warning: #f8961e;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 1rem;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: white;
            background-color: #f5f7ff;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1250px;
            margin: 0 auto;
            padding: 0 1rem;
            color:#f5f7ff;
        }
        #conc{
            color:#f9f6c0;
        }
        
        header {
           background: linear-gradient(135deg, var(--primary-dark), #240474);
            color: white;
            padding: 5rem 0 7rem;
            text-align: center;
            clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
            margin-bottom: -3rem;
            position: relative;
            z-index: 1;
        }
        
        header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom right, transparent 49%, #f5f7ff 50%);
        }
        
        h1 {
            font-size: 2.8rem;
            font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-weight: 700;
            margin-bottom: 1.5rem;
            line-height: 1.2;
        }
        
        header p {
            font-size: 1.25rem;
            font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            max-width: 700px;
            color:#ffffff;
            margin: 0 auto;
            opacity: 0.9;
        }
        
        h2 {
            font-size: 2.2rem;
            color: var(--primary-dark);
            font-family: Georgia, 'Times New Roman', Times, serif;
            margin: 3.5rem 0 2rem;
            position: relative;
            padding-bottom: 0.75rem;
            font-weight: 600;
        }
        
        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200px;
            height: 6px;
            background: var(--secondary);
            border-radius: var(--radius-sm);
        }
        
        h3 {
            font-size: 1.75rem;
            color: var(--primary);
            margin: 2.5rem 0 1.25rem;
            font-weight: 600;
        }
        
        h4 {
            font-size: 1.3rem;
            color: var(--dark);
            margin: 1.75rem 0 0.75rem;
            font-weight: 500;
        }
        
        p {
            margin-bottom: 1.5rem;
            color: rgb(0, 0, 0);
            font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 1.05rem;
            line-height: 1.7;
        }
        
        a {
            color: black;
            text-decoration: none;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        a:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 2rem;
            padding-left: 2rem;
            color:black;
        }
        
        li {
            margin-bottom: 0.75rem;
            color:black;
            line-height: 1.6;
        }
        
        strong {
            font-weight: 600;
            color: var(--primary-dark);
        }
        
        .nav {
            display: flex;
            justify-content: center;
            margin: 3rem 0 4rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .nav a {
            padding: 0.8rem 1.8rem;
            background-color: white;
            color: var(--primary);
            border-radius: 50px;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid rgba(67, 97, 238, 0.2);
            font-size: 0.95rem;
        }
        
        .nav a:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
            text-decoration: none;
        }
        
        .card {
            background-color: white;
            border-radius: var(--radius-lg);
            padding: 2.5rem;
            margin-bottom: 3rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }
        
        .card-highlight {
            border-left: 5px solid var(--primary);
            background-color: #f8f9fe;
        }
        
        pre {
            background: linear-gradient(135deg, var(--primary-dark), #190353);
            color: #ffffff;
            padding: 1.75rem;
            border-radius: var(--radius-md);
            overflow-x: auto;
            margin: 2rem 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            tab-size: 4;
            box-shadow: var(--shadow-sm);
        }
        
        code {
            font-family: 'Fira Code', monospace;
            background-color: rgba(67, 97, 238, 0.1);
            padding: 0.25em 0.5em;
            border-radius: var(--radius-sm);
            font-size: 0.9em;
            color: var(--primary-dark);
        }
        
        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        
        .example {
            background-color: #f0f7ff;
            padding: 1.75rem;
            border-radius: var(--radius-md);
            margin: 2rem 0;
            border-left: 5px solid var(--secondary);
            box-shadow: var(--shadow-sm);
        }
        
        .image-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2.5rem;
            margin: 3rem 0;
        }
        
        .image-card {
            flex: 1 1 450px;
            max-width: 60%;
            background: white;
            padding: 1.75rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .image-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg);
        }
        
        .image-card img {
            width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            box-shadow: var(--shadow-sm);
        }
        
        .image-caption {
            text-align: center;
            margin-top: 1.25rem;
            color: black;
            font-size: 0.95rem;
            font-style: italic;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
            margin: 3rem 0;
        }
        
        .feature-card {
            background: white;
            padding: 2rem;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-md);
        }
        
        .feature-card h4 {
            color: var(--primary);
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .conclusion-section {  
             background: linear-gradient(135deg, var(--primary-dark), #240474);
            color: rgb(0, 0, 0);
            padding: 4rem 2.5rem;
            border-radius: var(--radius-lg);
            margin: 5rem 0;
            position: relative;
            overflow: hidden;
        }
        
        .conclusion-section::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 200%;
            background: radial-gradient(circle, rgba(4, 43, 54, 0.1) 0%, transparent 70%);
            z-index: 0;
        }
        
        .conclusion-section h2 {
            color: white;
            position: relative;
        }
        
        .conclusion-section h2::after {
            background: var(--secondary);
        }
        #w{
            color:white;
        }
        
        .conclusion-section p, 
        .conclusion-section li {
            color: rgba(255, 255, 255, 0.9);
            position: relative;
        }
        
        .key-findings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
            margin: 3rem 0;
            position: relative;
        }
        
        .finding-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: var(--radius-md);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: transform 0.3s ease;
        }
        
        .finding-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .next-steps {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: var(--radius-md);
            margin-top: 2.5rem;
            position: relative;
            backdrop-filter: blur(5px);
        }
        
        #pp{
            color:#f0f7ff;
        }
        footer {
            text-align: center;
            padding: 4rem 0;
            margin-top: 5rem;
            background: linear-gradient(135deg, var(--primary-dark), #240474);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0 1.5rem;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            h2 {
                font-size: 1.8rem;
                margin: 3rem 0 1.5rem;
            }
            
            h3 {
                font-size: 1.5rem;
            }
            
            .nav {
                flex-direction: column;
                align-items: center;
                margin: 2rem 0 3rem;
                gap: 0.75rem;
            }
            
            .nav a {
                width: 100%;
                text-align: center;
                padding: 0.7rem;
            }
            
            .card {
                padding: 1.75rem;
            }
            
            .image-container {
                flex-direction: column;
                gap: 1.5rem;
                margin: 2rem 0;
            }
            
            .image-card {
                flex: 1 1 100%;
                padding: 1.5rem;
            }
            
            .grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .conclusion-section {
                padding: 2.5rem 1.5rem;
                margin: 3rem 0;
            }
            
            footer {
                padding: 3rem 0;
            }
        }

        /* Correction spécifique pour la section Psycopg2 */
        #psycopg2 {
            opacity: 1 !important;
            transform: none !important;
            display: block !important;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Étude: Architecture Python/PostgreSQL pour la Plateforme d'Optimisation des EDT Universitaires</h1>
            <p>Méthodologie complète pour l'analyse et l'optimisation des applications bases de données académiques</p>
        </div>
    </header>
    
    <div class="container">
        <div class="nav">
            <a href="#introduction">Introduction</a>
            <a href="#architecture">Architecture</a>
            <a href="#postgresql">PostgreSQL</a>
            <a href="#psycopg2">Psycopg2</a>
            <a href="#exemples">Exemples</a>
        </div>
        
        <div class="card" id="introduction">
            <section>
                <h2>Introduction</h2>
                <p>Cette étude présente une méthodologie moderne pour analyser et optimiser les interactions entre Python et PostgreSQL dans le contexte d'une plateforme d'optimisation des emplois du temps universitaires pour 13,000+ étudiants et 200+ formations.</p>

                <h3>Objectifs principaux</h3>
                <ul>
                    <li><strong>Conception optimisée</strong> d'un schéma relationnel pour gérer 13,000+ étudiants et 200+ formations</li>
                    <li><strong>Implémentation</strong> d'algorithmes d'optimisation pour la génération automatique d'emplois du temps</li>
                    <li><strong>Sécurisation</strong> des échanges entre l'interface Streamlit et PostgreSQL via Psycopg2</li>
                    <li><strong>Optimisation</strong> des performances pour atteindre l'objectif de génération en moins de 45 secondes</li>
                </ul>
                
                <div class="grid">
                    <div class="feature-card">
                        <h4>Modélisation académique</h4>
                        <p>Conception d'un schéma relationnel optimisé pour gérer 13,000+ étudiants, 200+ formations et leurs contraintes complexes (capacités salles, disponibilités, prérequis)</p>
                    </div>
                    <div class="feature-card">
                        <h4>Interface Streamlit/PostgreSQL</h4>
                        <p>Mécanismes avancés d'interaction entre Streamlit et PostgreSQL via Psycopg2 avec gestion optimisée des connexions pour le dashboard multi-acteurs.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Optimisation algorithmique</h4>
                        <p>Implémentation d'algorithmes d'optimisation pour la génération automatique d'emplois du temps avec détection et résolution de conflits en temps réel.</p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Section Architecture -->
        <div class="card" id="architecture">
            <section>
                <h2>Architecture Moderne Python/PostgreSQL</h2>
                <p>Diagramme clé illustrant l'interaction optimisée entre Python et PostgreSQL via Psycopg2 :</p>
                
                <div class="image-container">
                    <div class="image-card">
                        <img src="python_postgresql_connection_to_access_database.jpg" alt="Diagramme d'architecture Python DB API">
                        <div class="image-caption">Figure 1: Architecture complète Python DB API avec Psycopg2</div>
                    </div>
                </div>
                
                <h3>Composants clés</h3>
                <div class="grid">
                    <div class="feature-card">
                        <h4>Interface Streamlit</h4>
                        <p>Dashboard interactif multi-acteurs (administration, départements, étudiants) avec visualisations en temps réel.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Psycopg2</h4>
                        <p>Adaptateur haute performance pour PostgreSQL avec gestion avancée des transactions pour les pics de charge.</p>
                    </div>
                    <div class="feature-card">
                        <h4>PostgreSQL</h4>
                        <p>Moteur de base de données avec support des contraintes complexes (capacités salles, disponibilités, prérequis).</p>
                    </div>
                </div>
                
                <h3>Flux de données type</h3>
                <div class="example">
                    <pre><code># Exemple de flux dans l'application
def get_db():
    """Connexion base des donnes """
    try:
        conn = psycopg2.connect(
            dbname="ssbda",
            user="postgres",
            password="admin123",
            host="localhost",
            port="5433"
        )
        return conn
    except Exception as e:
        print(f"Erreur: {e}")
        return None

# Utilisation typique
conn = get_db()
if conn:
    with conn.cursor() as cur:
        cur.execute("SELECT * FROM examens WHERE date_exam >= %s", (datetime.now().date(),))
        examens = cur.fetchall()
    conn.close()</code></pre>
                </div>
            </section>
        </div>

        <!-- Section PostgreSQL -->
        <div class="card" id="postgresql">
            <section>
                <h2>PostgreSQL - Puissance et Flexibilité</h2>
                <p>PostgreSQL est un système de gestion de base de données relationnelle open-source offrant des fonctionnalités avancées pour les applications académiques.</p>
                
                <h3>Avantages clés</h3>
                <ul>
                    <li><strong>Robustesse</strong>: Stabilité éprouvée même avec des volumes de données importants (13k+ étudiants)</li>
                    <li><strong>Contraintes complexes</strong>: Support natif pour les contraintes CHECK, UNIQUE, FOREIGN KEY</li>
                    <li><strong>Extensibilité</strong>: Création de types, fonctions et opérateurs personnalisés</li>
                    <li><strong>Performances</strong>: Indexation avancée, partitionnement, parallélisation</li>
                    <li><strong>Sécurité</strong>: RBAC fin, chiffrement, audit détaillé</li>
                </ul>
                
                <h3>Installation et configuration</h3>
                <div class="example">
                    <pre><code># Installation sur Ubuntu/Debian
sudo apt update
sudo apt install postgresql postgresql-contrib

# Création de la base de données du projet
sudo -u postgres psql -c "CREATE DATABASE ssbda;"
sudo -u postgres psql -c "CREATE USER admin WITH PASSWORD 'admin123';"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE ssbda TO admin;"

# Configuration du fichier pg_hba.conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    ssbda           admin           127.0.0.1/32            md5</code></pre>
                </div>
                
                <h3>Optimisations recommandées</h3>
                <div class="grid">
                    <div class="feature-card">
                        <h4>Configuration mémoire</h4>
                        <p>Ajuster shared_buffers (25% RAM) et effective_cache_size (75% RAM) dans postgresql.conf</p>
                    </div>
                    <div class="feature-card">
                        <h4>Indexation stratégique</h4>
                        <p>Créer des index sur les colonnes fréquemment interrogées (date_exam, salle_id, module_id)</p>
                    </div>
                    <div class="feature-card">
                        <h4>Maintenance régulière</h4>
                        <p>Planifier VACUUM et ANALYZE automatiques avec autovacuum pour les tables fréquemment mises à jour</p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Section Psycopg2 - CORRIGÉE -->
        <div class="card card-highlight" id="psycopg2">
            <section>
                <h2>Psycopg2 - Interface Optimisée pour l'Application</h2>
                <p>Psycopg2 est l'adaptateur PostgreSQL utilisé pour connecter l'application Streamlit à la base de données avec une approche de connexion simplifiée adaptée au contexte académique.</p>
                
                <h3>Connexion de base adaptée au projet</h3>
                <div class="example">
                    <pre><code>import psycopg2

# Fonction de connexion identique à celle utilisée dans l'application
def get_db():
    """connexion  a la base des donnes """
    try:
        conn = psycopg2.connect(
            dbname="ssbda",           # Nom de la base
            user="postgres",          # Utilisateur PostgreSQL
            password="admin123",      # Mot de passe
            host="localhost",         # Serveur local
            port="5433"               # Port
        )
        return conn
    except Exception as e:
        print(f" Erreur de connexion: {e}")
        return None

# Utilisation typique dans l'application
def charger_donnees():
    """Charge des donnes depuis la base"""
    conn = get_db()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM etudiants")
            nb_etudiants = cursor.fetchone()[0]
            print(f"{nb_etudiants} étudiants chargés")
            return nb_etudiants
        finally:
            conn.close()  # Fermeture systématique
    return 0</code></pre>
                </div>

                <!-- Sous-section Connexions simplifiées -->
                <div class="card" id="psycopg2-simple">
                    <section>
                        <h3>Approche de Connexion Simplifiée</h3>
                        
                        <p><strong>Contexte :</strong> Pour notre application de gestion d'emplois du temps universitaires, nous avons opté pour une approche de connexion simplifiée sans pool de connexions, car :</p>
                        
                        <ul>
                            <li>L'application Streamlit gère une connexion par session utilisateur</li>
                            <li>Les pics de charge sont limités (administration universitaire)</li>
                            <li>La simplicité de maintenance est prioritaire</li>
                            <li>Gestion fine des erreurs et fermeture systématique des ressources</li>
                        </ul>
                    </section>
                </div>

                <!-- Section des curseurs -->
                <div class="card" id="psycopg2-cursors">
                    <section>
                        <h3>Gestion des Curseurs (Cursors)</h3>
                        
                        <p><strong>Définition :</strong> Un curseur permet de parcourir les résultats d'une requête SQL ligne par ligne, essentiel pour les gros volumes de données.</p>
                        
                        <h4>Utilisation dans le projet</h4>
                        <div class="example">
                            <pre><code># Exemple d'utilisation des curseurs dans l'application
def get_examens_par_date(date_debut, date_fin):
    """Récupère les examens dans une plage de dates"""
    conn = get_db()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT e.id, m.nom as module, e.date_exam, e.heure_debut, 
                       l.nom as salle, p.nom as professeur
                FROM examens e
                JOIN modules m ON e.module_id = m.id
                JOIN lieu_examen l ON e.salle_id = l.id
                JOIN professeurs p ON e.prof_surveillant_id = p.id
                WHERE e.date_exam BETWEEN %s AND %s
                ORDER BY e.date_exam, e.heure_debut
            """, (date_debut, date_fin))
            
            # Récupération par lot pour optimiser la mémoire
            examens = []
            while True:
                batch = cursor.fetchmany(100)  # 100 résultats à la fois
                if not batch:
                    break
                examens.extend(batch)
            
            return examens
        finally:
            cursor.close()
            conn.close()
    return []</code></pre>
                        </div>
                    </section>
                </div>

                <!-- Section Exemples concrets -->
                <div class="card" id="psycopg2-exemples-reels">
                    <section>
                        <h3>Exemples Concrets du Projet</h3>
                        
                        <h4>Vérification des disponibilités de salle</h4>
                        <div class="example">
                            <pre><code>def check_salle_disponible(conn, salle_id, date_exam, heure_debut, duree_minutes, examen_id=None):
    """Vérifie si une salle est disponible à un créneau (code réel du projet)"""
    try: 
        cursor = conn.cursor()
        
        heure_fin = (datetime.combine(date_exam, heure_debut) + 
                    timedelta(minutes=duree_minutes)).time()
        
        if examen_id:
            query = """
                SELECT COUNT(*) 
                FROM examens 
                WHERE salle_id = %s 
                AND date_exam = %s
                AND id != %s
                AND (
                    (heure_debut >= %s AND heure_debut < %s)
                    OR (heure_debut + INTERVAL '1 minute' * duree_minutes > %s 
                        AND heure_debut + INTERVAL '1 minute' * duree_minutes <= %s)
                    OR (heure_debut <= %s AND heure_debut + INTERVAL '1 minute' * duree_minutes >= %s)
                )
            """
            params = (salle_id, date_exam, examen_id, heure_debut, heure_fin,
                     heure_debut, heure_fin, heure_debut, heure_fin)
        else:
            query = """
                SELECT COUNT(*) 
                FROM examens 
                WHERE salle_id = %s 
                AND date_exam = %s
                AND (
                    (heure_debut >= %s AND heure_debut < %s)
                    OR (heure_debut + INTERVAL '1 minute' * duree_minutes > %s 
                        AND heure_debut + INTERVAL '1 minute' * duree_minutes <= %s)
                    OR (heure_debut <= %s AND heure_debut + INTERVAL '1 minute' * duree_minutes >= %s)
                )
            """
            params = (salle_id, date_exam, heure_debut, heure_fin,
                     heure_debut, heure_fin, heure_debut, heure_fin)
        
        cursor.execute(query, params)
        count = cursor.fetchone()[0]
        
        return count == 0  # True si disponible
        
    except Exception as e:
        print(f"Erreur lors de la vérification: {e}")
        return False</code></pre>
                        </div>
                        
                        <h4>Authentification utilisateur</h4>
                        <div class="example">
                            <pre><code>def authenticate_user(username, password):
    """Authentifie un utilisateur (adapté du code réel)"""
    conn = get_db()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT u.id, u.username, u.password_hash, r.nom as role_nom
                FROM utilisateurs u
                JOIN roles r ON u.role_id = r.id
                WHERE u.username = %s AND u.est_actif = TRUE
            """, (username,))
            
            user_data = cursor.fetchone()
            
            if user_data:
                user_id, stored_username, stored_hash, role = user_data
                
                # Vérification du mot de passe (SHA256)
                import hashlib
                hashed_password = hashlib.sha256(password.encode()).hexdigest()
                
                if hashed_password == stored_hash:
                    # Mise à jour du last_login
                    cursor.execute("""
                        UPDATE utilisateurs 
                        SET last_login = CURRENT_TIMESTAMP 
                        WHERE id = %s
                    """, (user_id,))
                    conn.commit()
                    
                    return {
                        'id': user_id,
                        'username': stored_username,
                        'role': role,
                        'authenticated': True
                    }
            
            return None  # Authentification échouée
                
        except Exception as e:
            print(f"Erreur d'authentification: {e}")
            return None
        finally:
            conn.close()
    
    return None</code></pre>
                        </div>
                    </section>
                </div>

                <h3>Bonnes pratiques appliquées</h3>
                <div class="grid">
                    <div class="feature-card">
                        <h4>Gestion des transactions</h4>
                        <p>Utilisation de commit/rollback pour garantir l'intégrité des données lors des opérations critiques.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Prévention des injections SQL</h4>
                        <p>Toujours utiliser les paramètres (%s) plutôt que l'interpolation de chaînes pour toutes les requêtes.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Fermeture systématique</h4>
                        <p>Utilisation de blocs try/finally pour garantir la fermeture des connexions et curseurs.</p>
                    </div>
                </div>
            </section>
        </div>

        <!-- Section Exemples -->
        <div class="card" id="exemples">
            <section>
                <h2>Exemples Concrets d'Optimisation</h2>
                <p>Implémentation des fonctionnalités clés de la plateforme avec optimisation des performances.</p>
                
                <h3>Table Departements</h3>
                <div class="example">
                    <pre><code>CREATE TABLE departements (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    responsable_id INTEGER REFERENCES professeurs(id),
    capacite_totale INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Index pour recherche rapide
CREATE INDEX idx_departements_nom ON departements(nom);
CREATE INDEX idx_departements_responsable ON departements(responsable_id);</code></pre>
                </div>

                <h3>Table Examens avec contraintes métier</h3>
                <div class="example">
                    <pre><code>CREATE TABLE examens (
    id SERIAL PRIMARY KEY,
    module_id INTEGER NOT NULL REFERENCES modules(id),
    prof_surveillant_id INTEGER REFERENCES professeurs(id),
    salle_id INTEGER NOT NULL REFERENCES lieu_examen(id),
    date_exam DATE NOT NULL,
    heure_debut TIME NOT NULL,
    duree_minutes INTEGER DEFAULT 120,
    statut VARCHAR(20) DEFAULT 'planifié',
    statut_validation VARCHAR(20) DEFAULT 'en_attente',
    nombre_inscrits INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES utilisateurs(id),
    validated_by INTEGER REFERENCES utilisateurs(id),
    validation_date TIMESTAMP,
    
    -- Contraintes métier
    CONSTRAINT chk_heure_examen CHECK (
        EXTRACT(HOUR FROM heure_debut) >= 8 AND 
        EXTRACT(HOUR FROM heure_debut) <= 19
    ),
    CONSTRAINT chk_duree CHECK (duree_minutes BETWEEN 60 AND 240),
    
    -- Contrainte d'unicité
    CONSTRAINT unique_examen_salle_creneau UNIQUE(salle_id, date_exam, heure_debut)
);

-- Index stratégiques pour performances
CREATE INDEX idx_examens_date ON examens(date_exam);
CREATE INDEX idx_examens_salle_date ON examens(salle_id, date_exam);
CREATE INDEX idx_examens_prof_date ON examens(prof_surveillant_id, date_exam);</code></pre>
                </div>
                
                <h3>Algorithme de génération automatique</h3>
                <div class="example">
                    <pre><code>class GenerateurPlanning:
    def __init__(self):
        self.penalites = {
            'sureffectif': 10,
            'surcharge_prof': 8,
            'surcharge_etudiant': 6,
            'formation_conflit': 5,
            'chevauchenent_prof': 8,
            'heure_hors_plage': 15
        }
    
    def generer_planning_optimise(self, conn, date_debut, date_fin):
        """Génère un planning optimisé"""
        try:
            cursor = conn.cursor()
            
            # Récupérer tous les modules non programmés
            cursor.execute("""
                SELECT m.id, m.nom, m.code_module, f.nom as formation,
                       COUNT(i.etudiant_id) as nb_etudiants
                FROM modules m
                JOIN formations f ON m.formation_id = f.id
                LEFT JOIN inscriptions i ON m.id = i.module_id
                WHERE NOT EXISTS (
                    SELECT 1 FROM examens ex 
                    WHERE ex.module_id = m.id 
                    AND ex.statut IN ('planifié', 'confirmé')
                )
                GROUP BY m.id, m.nom, m.code_module, f.nom
                ORDER BY COUNT(i.etudiant_id) DESC
            """)
            
            modules = cursor.fetchall()
            
            # Algorithme de placement optimisé
            placements = []
            for module in modules:
                module_id, module_nom, code_module, formation, nb_etudiants = module
                
                # Trouver une salle adaptée et un créneau disponible
                placement_trouve = self.trouver_meilleur_placement(
                    conn, module_id, nb_etudiants, date_debut, date_fin
                )
                
                if placement_trouve:
                    placements.append(placement_trouve)
            
            return placements
            
        except Exception as e:
            print(f"Erreur génération planning: {e}")
            return []</code></pre>
                </div>
                
                <h3>Détection des conflits</h3>
                <div class="example">
                    <pre><code>def detecter_conflits_etudiants(conn, date_debut, date_fin):
    """Détecte les étudiants avec plusieurs examens le même jour"""
    query = """
    SELECT e.id, e.nom, e.prenom, COUNT(DISTINCT ex.id) as nb_examens, ex.date_exam
    FROM etudiants e
    JOIN inscriptions i ON e.id = i.etudiant_id
    JOIN examens ex ON i.module_id = ex.module_id
    WHERE ex.date_exam BETWEEN %s AND %s
    AND ex.statut IN ('planifié', 'confirmé')
    GROUP BY e.id, e.nom, e.prenom, ex.date_exam
    HAVING COUNT(DISTINCT ex.id) > 1
    ORDER BY nb_examens DESC
    """
    
    conn = get_db()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute(query, (date_debut, date_fin))
            return cursor.fetchall()
        finally:
            conn.close()
    return []</code></pre>
                </div>
            </section>
        </div>
        
        <!-- Section Conclusion -->
        <section id="conclusion" class="conclusion-section">
            <div class="container">
                <h2>Conclusion et Perspectives</h2>
                
                <div class="key-findings">
                    <div class="finding-card">
                        <h4 id="conc">PostgreSQL pour l'éducation</h4>
                        <p>La robustesse de PostgreSQL permet de gérer efficacement les volumes importants de données académiques avec des contraintes complexes tout en maintenant des performances optimales.</p>
                    </div>
                    
                    <div class="finding-card">
                        <h4 id="conc">Psycopg2 adapté au contexte</h4>
                        <p>L'approche simplifiée sans pool de connexions s'est avérée optimale pour le contexte universitaire, offrant simplicité de maintenance et gestion robuste des erreurs.</p>
                    </div>
                    
                    <div class="finding-card">
                        <h4 id="conc">Architecture Streamlit/PostgreSQL</h4>
                        <p>La combinaison Streamlit + Psycopg2 permet un développement rapide d'interfaces interactives tout en garantissant des performances optimales pour la gestion des emplois du temps.</p>
                    </div>
                </div>

                <div class="next-steps">
                    <h3 id="conc">Choix techniques justifiés</h3>
                    <ol>
                        <li><strong id="conc">Connexions simples sans pool</strong>: Adapté au contexte universitaire avec des pics de charge prévisibles et gestion simplifiée</li>
                        <li><strong id="conc">SHA256 pour l'authentification</strong>: Suffisant pour la sécurité requise dans un contexte interne universitaire</li>
                        <li><strong id="conc">Streamlit comme interface</strong>: Permet un développement rapide d'un dashboard multi-rôles sans frontend complexe</li>
                        <li><strong id="conc">Algorithmes customisés</strong>: Adaptés aux contraintes spécifiques (spécialités, capacités, quotas)</li>
                    </ol>
                </div>
            </div>
        </section>
    </div>
    
    <footer>
        <div class="container">
            <p id="pp">Étude réalisée par Sellami Siham - 2025</p>
            <p id="pp">Application des concepts BDA Python/PostgreSQL à un contexte académique réel</p>
            <p id="pp">Technologies : PostgreSQL | Python 3.9+ | Psycopg2 | Streamlit | Algorithmes d'optimisation</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Animation douce au scroll
            const animateOnScroll = () => {
                const elements = document.querySelectorAll('.card, .feature-card, .finding-card');
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.style.opacity = 1;
                            entry.target.style.transform = 'translateY(0)';
                        }
                    });
                }, { 
                    threshold: 0.1,
                    rootMargin: '0px 0px -100px 0px'
                });
                
                elements.forEach(el => {
                    el.style.opacity = 0;
                    el.style.transform = 'translateY(30px)';
                    el.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                    observer.observe(el);
                });
            };
            
            // Navigation fluide
            const smoothScroll = () => {
                document.querySelectorAll('.nav a').forEach(anchor => {
                    anchor.addEventListener('click', function(e) {
                        e.preventDefault();
                        const targetId = this.getAttribute('href');
                        const targetElement = document.querySelector(targetId);
                        
                        window.scrollTo({
                            top: targetElement.offsetTop - 100,
                            behavior: 'smooth'
                        });
                        
                        // Mise en évidence de l'élément cible
                        if (targetElement.classList.contains('card')) {
                            targetElement.style.boxShadow = '0 0 0 3px rgba(76, 201, 240, 0.5)';
                            setTimeout(() => {
                                targetElement.style.boxShadow = '';
                            }, 2000);
                        }
                    });
                });
            };
            
            animateOnScroll();
            smoothScroll();
            
            // Ajout d'un bouton "Retour en haut"
            const backToTop = document.createElement('div');
            backToTop.innerHTML = '↑';
            backToTop.style.position = 'fixed';
            backToTop.style.bottom = '2rem';
            backToTop.style.right = '2rem';
            backToTop.style.width = '3rem';
            backToTop.style.height = '3rem';
            backToTop.style.backgroundColor = 'var(--primary)';
            backToTop.style.color = 'white';
            backToTop.style.borderRadius = '50%';
            backToTop.style.display = 'flex';
            backToTop.style.justifyContent = 'center';
            backToTop.style.alignItems = 'center';
            backToTop.style.cursor = 'pointer';
            backToTop.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            backToTop.style.opacity = '0';
            backToTop.style.transition = 'opacity 0.3s ease';
            backToTop.style.zIndex = '1000';
            
            backToTop.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            document.body.appendChild(backToTop);
            
            window.addEventListener('scroll', () => {
                if (window.scrollY > 500) {
                    backToTop.style.opacity = '1';
                } else {
                    backToTop.style.opacity = '0';
                }
            });
        });
    </script>
</body>
</html>